# Лабораторная работа #2: Model-View-ViewModel

-----------------------
* [Цели](#Цели)
* [Задачи](#Задачи)
* [Типичные ошибки](#Типичные-ошибки)
* [Инструкции](#Инструкции)
   * [Установка JavaFX &amp; Scene Builder](#Установка-javafx--scene-builder)
   * [Предварительная работа](#Предварительная-работа)
   * [Реализация](#Реализация)
      * [Общий алгоритм](#Общий-алгоритм)
      * [Детальные инструкции](#Детальные-инструкции)
         * [View](#view)
         * [ViewModel](#viewmodel)
         * [View](#view-1)
* [Заключение](#Заключение)
------------------------

<!-- TODO

 -->

## Цели

1. Ознакомиться c паттернами организации GUI на примере Model-View-ViewModel (MVVM).
1. Освоить практику реализации логики взаимодействия с пользователем согласно Test-Drived Design (TDD) подходу. Как следствие, получить покрытие презентационной логики модульными тестами.

## Задачи

1. Расширить Java-проект с которым предстоит работать до трех сборок: `Model`, `View` и `ViewModel`.
    - Первый компонент фактически уже реализован в рамках первой лабораторной работы, нужно будет только обновить build-скрипты.
    - Сборка `ViewModel` должна представлять собой отдельный Java-проект, ответственностью которого является реализация логики взаимодействия с пользователем (обработка ввода, вывод результатов). Разработка `ViewModel` должна вестись согласно практике TDD.
    - Сборка `View` также представляет собой отдельный Java-проект, основной частью которого является графическая форма. Предполагается, что форма спроектирована и реализована в среде Scene Builder на основе платформы JavaFX.
1. Поскольку проект будет состоять из нескольких сборок, нужно соответствующим образом обновить сборочные скрипты Gradle. Они должны допускать импорт проекта в IntelliJ IDEA, а также сборку и тестирование в Travis CI.
1. Как и в прошлый раз, особое внимание нужно обратить на тщательное автоматическое тестирование. При нехватке или плохом качестве тестов будет требоваться доработка. Результаты работы следует присылать в виде пулл-реквеста, и добиться прохождения всех проверок в системе Travis CI.
    - Напоминаем, что стабилизацию разумнее всего выполнять на Travis, который прикреплен к вашему форку, чтобы не приходилось ждать других участников. Поэтому не забудьте включить тестирование для своего форка индивидуально, и не забывайте регулярно обновлять состояние ветки `origin/master` до состояния `upstream/master`.

## Типичные ошибки

TBD

## Инструкции

### Установка JavaFX & Scene Builder

Необходимо скачать и поставить javafx-sdk-11.0.2. Затем установить переменную окружения `JFXRT_HOME` до подпапки `lib` в пакете. Вот как можно проверить на UNIX системах, что переменная окружения была установлена

```bash
$ echo $JFXRT_HOME
$ <PATH_TO_JAVAFX>/javafx-sdk-11.0.2/lib
```

Для проектирования графического интерфейса c JavaFX, надо дополнительно установить [Scene Builder 2.0][sceneBuilder].

### Предварительная работа

Данная лабораторная работа потребует более серьезных усилий, поэтому сперва необходимо убедиться, что все окружение настроено правильно.

1. Первым делом стоит получить последние коды из репозитория (стоит делать это всякий раз перед началом выполнения лабораторной работы).
    ```bash
        $ cd agile-course-practice
        $ git fetch upstream
        $ git checkout master
        $ git rebase upstream/master
        $ git checkout -b lab2-mvvm-SOMETHING
    ```
1. После этого стоит убедиться, что все компилируется и работает:
    ```bash
        $ gradle check
    ```
1. Все модули должны собраться и запуститься тесты. Стоит обратить внимание на папку с примером `korniakov-kirill-lab2`, в которой находится требуемая структура проекта, в том числе модуль `ViewModel` и тесты на него.

1. Затем стоит сгенерировать проект для IDEA, и открыть его. Внимание: этот шаг возможно уничтожит ваш собственный проект IDEA (папка `.idea`), но он вам и не нужен.
    ```bash
        $ gradle clean cleanIdea cleanIdeaWorkspace
        $ gradle idea
    ```
1. Теперь можно запустить IDEA и открыть проект, который был сгенерирован Gradle в директории `agile-course-practice` (файл `code.ipr`). __Внимание__: желательно именно генерировать проект и после открывать (не импортировать) его в IDEA. Теоретически, IDEA должна сама прожевывать Gradle-скрипты, но почему-то у нее это получается не до конца. Хотя в 2019 году вроде это уже начало работать по-нормальному.

1. Все что осталось — это убедиться, что из IDEA вы можете запускать тесты и GUI-приложение. Для этого в браузере проекта (левая часть окна IDEA) найдите папку `korniakov-kirill-lab2` и раскройте ее. Там будет три подпроекта.
     - На проектах `Model` и `ViewModel` можно нажать правую кнопку мыши и выбрать команду `Run 'All Tests'`. В обоих случаях все тесты должны успешно пройти.
     - В проекте `View` нужно полностью раскрыть папку `src` и найти класс `Main`. На нем можно нажать правую кнопку и выбрать пункт `Run 'Main.main()'`. Запустится форма, представляющая собой калькулятор комплексных чисел. Форма примитивная, но нам ее будет достаточно.
      - Чтобы все работало, необходимо в настройках IDE установить следующие опции. Добавьте в VM Options следующие аргументы: `--module-path <PATH_TO_JAVAFX>/javafx-sdk-11.0.2/lib/ --add-modules javafx.fxml,javafx.controls`
    - Если решите открыть форму из проекта примера в Scene Builder, учтите что он может не открывать FXML разметку с установленной `ViewModel`, чтобы это поправить, закомментирйуте на время изменения тег `define` в fxml-файле `View`. Не забудьте потом раскомментировать!

Собственно на этом все, теперь вашей задачей является достижение аналогичного состояния в своем проекте. Нужно на основе модели, созданной в рамках первой лабы, реализовать слои `ViewModel` и `View`.

### Реализация

#### Общий алгоритм

Предполагается, что слой `Model` у вас уже готов. Там содержится главный класс и тесты на него. Мы, таким образом, сосредоточимся на реализации паттерна MVVM. Высокоуровневая последовательность шагов следующая:

1. Создать новый проект `View` и спроектировать в нем GUI, используя технологию JavaFX и дизайнер Scene Builder. На этом этапе не нужно привязывать форму к вашим классам.
1. Создать новый проект `ViewModel`, являющийся моделью созданного выше GUI. Его разработка должна вестись по TDD.
1. Вернуться к `View`, сделать так, чтобы класс использовал `ViewModel`, настроить соответствующим образом привязку графических компонентов к полям класса.

#### Детальные инструкции

##### View

Первым делом предлагается сверстать графическую форму в IDEA. Мы делаем это вперед `ViewModel` только затем, чтобы продумать интерфейс и логику взаимодействия с пользователем. Чтобы создать пустой проект, необходимо выполнить следующие шаги:

1. Создать директорию `View` в своей подпапке.

1. Создать набор вложенных директорий для исходников, подобно тому, как это сделано в вашей `Model` и проекте-примере:
    ```
        code/korniakov-kirill-lab2/View/src/main/java/ru/unn/agile/ComplexNumber/view/
        code/korniakov-kirill-lab2/View/src/test/java/ru/unn/agile/ComplexNumber/view/
    ```

1. Положить в вашу папку `View` файл `build.gradle` следующего примерного содержания:
    ```groovy
        plugins {
          id 'application'
          id 'org.openjfx.javafxplugin' version '0.0.8'
        }

        apply plugin: 'application'
        mainClassName = 'ru.unn.agile.ComplexNumber.view.Main'

        javafx {
            version = "11.0.2"
            modules = [ 'javafx.controls', 'javafx.graphics', 'javafx.base', 'javafx.fxml' ]
        }

        dependencies {
            compile project(':korniakov-kirill-lab2-ViewModel')
    }
    ```

1. Затем необходимо добавить этот файл в общий проект. Снова идем в глобальный `settings.gradle` и добавляем две строки в вашей секции, "регистрирующие" директорию `View` и соответствующий ей проект.

1. Теперь можно сгенерировать проект для IDEA, чтобы открыть его и приступить к проектированию формы. Выполняем следующую команду в консоли:
    ```bash
        $ cd agile-course-practice
        $ gradle korniakov-kirill-lab2-View:idea # change the project name to yours
    ```

1. Сгенерированный проект можно снова открыть в IDEA. Либо, если IDEA оставалась открытой, среда сама заметит изменения в файлах проекта и предложит перезагрузить проект. Нужно просто согласиться. Как результат, вы должны увидеть в своей папке уже два подпроекта: `Model` и `View`.
1. Теперь следует добавить пустую форму:
    - В проекте `View` внутри папки `src` создайте папку `resources`, внутри которой воссоздайте используемую структуру папок для классов (в проекте-примере это `ru/unn/agile/ComplexNumber/view`).
    - По аналогии с примером, добавьте `Main.java`, `<Insert-your-project-name>.java` внутрь `src/main/java/...`, FXML файл с разметкой в `src/main/resources/...`. Можно воспользоваться шаблоном разметки ниже, где в `id` контроллера укажите полное имя своего класса.

    ```xml
        <?xml version="1.0" encoding="UTF-8"?>

        <?import javafx.scene.layout.*?>
        <AnchorPane xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ru.unn.agile.ComplexNumber.view.Calculator">
        </AnchorPane>
    ```
    - После этого файл разметки можно будет открыть в Scene Builder из IDEA (ПКМ на FXML файле->Open In SceneBuilder) или запустить Scene Builder самостоятельно и открыть в нем нужный файл.

1. Процесс дизайна формы с JavaFX интуитивно понятен, вот несколько статей по теме в помощь:
    - [Using Scene Builder with IntelliJ IDEA][sbWithIDEA],
    - [FXML: Why It Rocks, And The Next Phase][fxmlRocks],
    - [JavaFX GUI development: FXML vs Java code][javafxGui].

1. Чтобы запустить форму, нажмите правой клавишей мыши по классу `Main` и выберите "Run Main.main".

1. Таким образом, предстоит сверстать форму, которая позволяла бы пользоваться вашим классом. Саму привязку класса делать не нужно, следует лишь зарезервировать поля.

1. Для составления отчета о покрытии тестами и успешного прохождения проверки в Travis, необходимо добавить фиктивный тест так, как это сделано в проекте-примере.

1. Результаты своей работы следует зафиксировать очередным коммитом в Git. Также можно сделать `git push` в свой репозиторий на GitHub, чтобы Travis снова прогнал тесты.

##### ViewModel

Далее следует приступить к реализации `ViewModel`. По своей сути этот класс является моделью вашей графической формы (что собственно следует из названия). Таким образом, в нем следует завести поля, соответствующие графическим элементам на вашем интерфейсе. Так, текстовые поля и метки отобразятся в обычные строки, выпадающие списки можно "перевести" в поле типа `enum`. А нажатие на кнопку можно обрабатывать как вызов обычного метода `ViewModel`.

Далее рассмотрим процесс реализации `ViewModel` по шагам:

1. Аналогично тому, как создавались подпапки `Model` и `View`, нужно создать директорию `ViewModel`.
1. В ней снова следует создать вложенную структуру папок для Java-исходников и тестов, полностью аналогично тому, как это сделано в директории `Model`. Единственное отличие, что имя Java пакета должно быть `viewmodel`, то есть полное имя выглядит примерно следующим образом: `package ru.unn.agile.ComplexNumber.viewmodel;`.
1. Затем следует создать `build.gradle` файл, и положить его в корень вашей директории `ViewModel`. Этот файл должен указывать системе сборки на исходники ваших классов и тестов, плюс указывать зависимость от вашего проекта `Model`. Вот примерный вид `build.gradle` файла:
    ```groovy
        plugins {
          id 'org.openjfx.javafxplugin' version '0.0.8'
        }

        javafx {
            version = "11.0.2"
            modules = [ 'javafx.base' ]
        }

        dependencies {
            compile project(':korniakov-kirill-lab2-Model')
        }
    ```
1. Следующим шагом следует добавить созданный подпроект в систему сборки. Для этого снова открываем общий `settings.gradle` файл добавлем еще две строки в вашей секции. Как результат, вы теперь можете сгенерировать проект IDEA:
    ```bash
        $ cd agile-course-practice
        $ gradle korniakov-kirill-lab2-ViewModel:idea
    ```
1. Теперь можно открыть проект в IDEA и начать разработку согласно TDD практике. Стоит завести во `ViewModel` строковые поля, соответствующие входным агрументам, и метке статуса. Первым тестом может быть проверка на то, что выводятся корректные значения по умолчанию (например пустые строки для входных аргументов). Затем можно проверить, что при некорректном вводе от пользователя (например пустой ввод), выводится сообщение об ошибке.
1. После этого уже можно переходить к полноценной реализации логики взаимодействия с пользователем. Пишутся тесты на все типичные сценарии взаимодействия, после чего эта логика реализуется по `ViewModel`. Стоит обратить особое внимание на то, что на этом этапе нет никакой необходимости использовать вашу реальную `View`.
1. В качестве отдельного упражнения можно реализовать логику активации/деактивации контролов в зависимости от того, является ли корректным ввод. За инструкциями следует обратиться к проекту-примеру.
1. Когда разработка `ViewModel` будет закончена, стоит убедиться, что все созданные тесты успешно проходят (`$ gradle korniakov-kirill-lab2-ViewModel:check`). Как обычно, рекомендуется сделать коммит и послать коды на тестирование Travis.

##### View

Последним шагом следует связать `View` и `ViewModel`. Сделать это относительно просто:

1. Первым делом нужно добавить зависимость `View` от `ViewModel`. Для этого открываем `build.gradle` в вашей директории `View` и добавляем информацию про зависимость:
    ```groovy
        dependencies {
            compile project(':korniakov-kirill-lab2-ViewModel')
        }
    ```
1. Затем перегенерируем IDEA проект (`gradle korniakov-kirill-lab2-View:idea`) и снова открываем его в IDE.
1. Далее следует завести поле типа `ViewModel` в вашем классе формы.
1. Последнее, что осталось сделать - это осуществить привязку полей реальной формы и ее модели, то есть `View` и `ViewModel`. JavaFX поддерживает автоматическое связывание моделей с `View`. `View` содержит различные элементы управления (`Button`, `TextField`, ...), информация в которые (или из которых) поступает в `Model` для обработки.
    - Чтобы соединить данные в модели и `View` необходимо создать свойство (property) в `ViewModel` и связать его со свойством объекта `View`. В качестве примера рассмотрим класс `Label` -- элемент управления с нередактируемым текстовым полем. У него есть свойство `text`, в которое выводится :open_mouth: текст.
    - В проекте-примере `ViewModel` подсчитывает результат арифметического действия и выводит его в текстовое поле лейбла. Для связи результата вычислений и текста в лейбле, создаем в `ViewModel` свойство `StringProperty result`, и, после выполениня арифметической опрерации, устанавлеваем в нем текст с результатом: `result.set("5")`.
    - В FXML файле разметки добавляем аттрибут с связью: `<Label text="${viewModel.result}" .../>`. Так же, чтобы JavaFX мог получить доступ из FXML к свойству в `ViewModel`, необходимо объявить соответствующий публичный метод в `ViewMode`l: `get<ExactPropertyName>()`, для StringProperty `result` должен быть метод `String getResult()`.
    - Это все, теперь текст лейбла будет автоматически обновлятся при каждом вычислении результата.

__Замечания__

- Scene Builder может не открывать FXML разметку с установленной `ViewModel`, чтобы это поправить, закомментирйуте на время изменения тег `define` во `View`. Не забудьте потом раскомментировать!
- Чтобы JavaFX нашёл нужную `ViewModel` для `View`, ее необходимо объявить в теге `define` FXML.
- Binding может быть "one-way" (при обновлении `ViewModel`, данные `View` обновляются автоматически) и "two-way" (данные будут так же обновляться в `ViewModel` при изменении из в `View`, что например актуально для `TextField`), подробнее [здесь][msdnBinding]. На настоящий момент FXML не поддерживает "two-way" binding, его нужно установить вручную (при помощи функции `bindBidirectional()`, подробнее в `Calculator.java`).

## Заключение

На этом выполнение лабораторной работы заканчивается. Стоит убедиться, что тестами покрыты все случаи использования формы (в том числе некорректный ввод). Также стоит просмотреть весь проект, вероятно возможно его упростить и отрефакторить какие-то части.

После этого стоит положить все изменения в Git, сделать pull request и пройти ревью в обычном порядке.

<!-- LINKS -->

[jdk8]: <http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html>
[installJavaUbuntu]: <http://www.linuxrussia.com/2013/04/oracle-java-7-ubuntu-1304-1204-1210.html>
[sceneBuilder]: https://www.oracle.com/technetwork/java/javase/downloads/javafxscenebuilder-info-2157684.html
[sbWithIDEA]: <https://docs.oracle.com/javafx/scenebuilder/1/use_java_ides/sb-with-intellij.htm>
[fxmlRocks]: <http://fxexperience.com/2011/10/fxml-why-it-rocks-and-the-next-phase/>
[javafxGui]: <http://www.first8.nl/blog/javafx-gui-development-fxml-vs-java-code/>
[msdnBinding]: <http://msdn.microsoft.com/en-us/library/gg405484%28v=pandp.40%29.aspx>
